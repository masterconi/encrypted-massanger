{
  "version": 3,
  "sources": ["../browser-shim.js", "../node_modules/ws/browser.js", "../src/client/browser.ts", "../src/client/client.ts", "../src/crypto/keygen.ts", "../node_modules/@noble/curves/src/ed25519.ts", "../node_modules/@noble/hashes/src/sha512.ts", "../node_modules/@noble/hashes/src/_sha2.ts", "../node_modules/@noble/hashes/src/_assert.ts", "../node_modules/@noble/hashes/src/utils.ts", "../node_modules/@noble/hashes/src/crypto.ts", "../node_modules/@noble/hashes/src/_u64.ts", "../node_modules/@noble/curves/src/abstract/edwards.ts", "../node_modules/@noble/curves/src/abstract/modular.ts", "../node_modules/@noble/curves/src/abstract/utils.ts", "../node_modules/@noble/curves/src/abstract/curve.ts", "../node_modules/@noble/curves/src/abstract/montgomery.ts", "../src/crypto/constants.ts", "../src/crypto/ratchet.ts", "../src/crypto/hkdf.ts", "../node_modules/@noble/hashes/src/hmac.ts", "../node_modules/@noble/hashes/src/sha256.ts", "../src/protocol/handshake.ts", "../src/crypto/encryption.ts", "../src/protocol/message.ts", "../src/client/browser-websocket.ts"],
  "sourcesContent": ["// Complete Buffer polyfill for browser environments\n// Provides minimal API surface needed for cryptographic operations\n\nclass BrowserBuffer extends Uint8Array {\n  constructor(input) {\n    if (typeof input === 'number') {\n      super(input);\n    } else if (input instanceof ArrayBuffer) {\n      super(input);\n    } else if (input instanceof Uint8Array) {\n      super(input);\n    } else if (Array.isArray(input)) {\n      super(input);\n    } else {\n      super(0);\n    }\n  }\n\n  static from(data, encoding) {\n    if (typeof data === 'string') {\n      if (encoding === 'hex') {\n        return BrowserBuffer.fromHex(data);\n      } else if (encoding === 'base64') {\n        return BrowserBuffer.fromBase64(data);\n      } else {\n        const bytes = new TextEncoder().encode(data);\n        return new BrowserBuffer(bytes);\n      }\n    } else if (data instanceof ArrayBuffer) {\n      return new BrowserBuffer(new Uint8Array(data));\n    } else if (data instanceof Uint8Array) {\n      return new BrowserBuffer(data);\n    } else if (Array.isArray(data)) {\n      return new BrowserBuffer(data);\n    }\n    throw new Error('Unsupported data type for Buffer.from');\n  }\n\n  static fromHex(hex) {\n    const cleaned = hex.replace(/[^0-9a-fA-F]/g, '');\n    if (cleaned.length % 2 !== 0) {\n      throw new Error('Invalid hex string');\n    }\n    const bytes = new Uint8Array(cleaned.length / 2);\n    for (let i = 0; i < cleaned.length; i += 2) {\n      bytes[i / 2] = parseInt(cleaned.substr(i, 2), 16);\n    }\n    return new BrowserBuffer(bytes);\n  }\n\n  static fromBase64(base64) {\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return new BrowserBuffer(bytes);\n  }\n\n  toString(encoding) {\n    if (encoding === 'hex') {\n      return Array.from(this)\n        .map(b => b.toString(16).padStart(2, '0'))\n        .join('');\n    } else if (encoding === 'base64') {\n      const binaryString = String.fromCharCode(...Array.from(this));\n      return btoa(binaryString);\n    } else {\n      return new TextDecoder().decode(this);\n    }\n  }\n\n  slice(start, end) {\n    const sliced = super.slice(start, end);\n    return new BrowserBuffer(sliced);\n  }\n}\n\n// Install Buffer polyfill\nif (typeof globalThis.Buffer === 'undefined') {\n  globalThis.Buffer = BrowserBuffer;\n}\n\n// Install process polyfill\nif (typeof globalThis.process === 'undefined') {\n  globalThis.process = { \n    env: {},\n    version: 'browser',\n    platform: 'browser'\n  };\n}\n\n// Install crypto polyfill if needed\nif (typeof globalThis.crypto === 'undefined' && typeof window !== 'undefined' && window.crypto) {\n  globalThis.crypto = window.crypto;\n}\n\nexport { BrowserBuffer as Buffer };\n", "'use strict';\n\nmodule.exports = function () {\n  throw new Error(\n    'ws does not work in the browser. Browser clients must use the native ' +\n      'WebSocket object'\n  );\n};\n", "/**\n * Browser-compatible client entry point\n * Exports the client for use in web applications\n */\n\nimport { SecureMessengerClient } from './client.js';\nimport type { ClientConfig } from './client.js';\nimport { BrowserWebSocket } from './browser-websocket.js';\n\n// Re-export for browser usage\nexport { SecureMessengerClient, BrowserWebSocket };\nexport type { ClientConfig };\n\n// Export crypto utilities for browser use\nexport {\n  generateIdentityKeyPair,\n  generateEphemeralKeyPair,\n} from '../crypto/keygen.js';\n\nexport type {\n  IdentityKeyPair,\n} from '../crypto/types.js';\n", "/**\n * Secure Messenger Client\n * \n * Main client implementation with:\n * - Secure connection management\n * - Message encryption/decryption\n * - Offline message queueing\n * - Delivery acknowledgments\n * - Automatic retry with exponential backoff\n */\n\nimport type {\n  IdentityKeyPair,\n  RatchetState,\n} from '../crypto/types.js';\nimport {\n  generateIdentityKeyPair,\n  generateEphemeralKeyPair,\n} from '../crypto/keygen.js';\nimport {\n  createRatchetState,\n  initializeRatchet,\n  cleanupRatchet,\n} from '../crypto/ratchet.js';\nimport {\n  createHandshakeInit,\n  processHandshakeResponse,\n  type HandshakeState,\n} from '../protocol/handshake.js';\nimport {\n  encryptMessage,\n  type EncryptedMessageData,\n} from '../protocol/message.js';\n\nexport interface ClientConfig {\n  serverUrl: string;\n  identityKey?: IdentityKeyPair;\n  WebSocketImpl?: any;\n  onMessage?: (senderId: string, message: Uint8Array) => void;\n  onError?: (error: Error) => void;\n  onConnected?: () => void;\n  onDisconnected?: () => void;\n}\n\n/**\n * Standard interface for WebSocket connection\n * Compatible with both browser WebSocket and 'ws' package\n */\nexport interface WebSocketConnection {\n  readonly readyState: number;\n  send(data: any): void;\n  close(code?: number, reason?: string): void;\n  on(event: string, listener: (...args: any[]) => void): void;\n  removeListener(event: string, listener: (...args: any[]) => void): void;\n}\n\nexport interface QueuedMessage {\n  messageId: Uint8Array;\n  recipientId: string;\n  encryptedData: EncryptedMessageData;\n  timestamp: number;\n  retryCount: number;\n  nextRetry: number;\n}\n\nexport class SecureMessengerClient {\n  private config: ClientConfig;\n  private identityKey: IdentityKeyPair;\n  private ws: WebSocketConnection | null = null;\n  private handshakeState: HandshakeState | null = null;\n  private ratchetStates: Map<string, RatchetState> = new Map();\n  private messageQueue: QueuedMessage[] = [];\n  private ackWaiters: Map<string, (success: boolean) => void> = new Map();\n  private connected = false;\n  private reconnectTimer: NodeJS.Timeout | null = null;\n  private retryBackoff = 1000;\n  private WebSocketImpl: any;\n\n  constructor(config: ClientConfig) {\n    this.config = config;\n\n    // Validate or generate identity key\n    if (config.identityKey) {\n      // Validate the provided identity key\n      if (config.identityKey.publicKey.length !== 32) {\n        throw new Error(`Invalid identity public key size: ${config.identityKey.publicKey.length}, expected 32`);\n      }\n      if (config.identityKey.privateKey.length !== 64) {\n        throw new Error(`Invalid identity private key size: ${config.identityKey.privateKey.length}, expected 64`);\n      }\n      this.identityKey = config.identityKey;\n    } else {\n      this.identityKey = generateIdentityKeyPair();\n    }\n\n    if (config.WebSocketImpl) {\n      this.WebSocketImpl = config.WebSocketImpl;\n    } else if (typeof WebSocket !== 'undefined' && typeof (WebSocket.prototype as any).on === 'function') {\n      // Only use global WebSocket if it has the .on() method (ws module or browser implementation)\n      // Native Node.js WebSocket in v24+ has addEventListener but not .on()\n      this.WebSocketImpl = WebSocket;\n    } else {\n      // Will be loaded asynchronously in Node.js (ws module)\n      this.WebSocketImpl = null;\n    }\n  }\n\n  /**\n   * Ensure WebSocket implementation is loaded\n   */\n  private async ensureWebSocket(): Promise<void> {\n    if (this.WebSocketImpl) {\n      return;\n    }\n\n    try {\n      const ws = await import('ws');\n      this.WebSocketImpl = ws.default;\n    } catch (error) {\n      throw new Error(`Failed to load WebSocket implementation: ${error}`);\n    }\n  }\n\n  /**\n   * Connect to the server and perform handshake\n   */\n  async connect(): Promise<void> {\n    await this.ensureWebSocket();\n\n    if (this.ws && this.ws.readyState === 1) {\n      return;\n    }\n\n    return new Promise((resolve, reject) => {\n      try {\n        const ws = new this.WebSocketImpl(this.config.serverUrl);\n        this.ws = ws;\n\n        ws.on('open', async () => {\n          try {\n            await this.performHandshake();\n            this.connected = true;\n            this.retryBackoff = 1000;\n\n            // Now attach the general message handler AFTER handshake is complete\n            ws.on('message', async (data: any) => {\n              try {\n                await this.handleMessage(data);\n              } catch (error) {\n                this.config.onError?.(error as Error);\n              }\n            });\n\n            this.config.onConnected?.();\n            this.processMessageQueue();\n            resolve();\n          } catch (error) {\n            this.config.onError?.(error as Error);\n            reject(error);\n          }\n        });\n\n        ws.on('error', (error: Error) => {\n          this.config.onError?.(error);\n          reject(error);\n        });\n\n        ws.on('close', (code: number, reason: string) => {\n          this.connected = false;\n          this.config.onDisconnected?.();\n\n          // Don't reconnect on fatal errors or normal closure\n          // 1000: Normal\n          // 1002: Protocol Error\n          // 1003: Unsupported Data\n          // 1007: Invalid Frame Payload Data (likely malformed message)\n          // 1008: Policy Violation (Rate limit)\n          // 1009: Message Too Big\n          // 1011: Internal Error\n          if ([1000, 1002, 1003, 1007, 1008, 1009, 1011].includes(code)) {\n            console.warn(`[Client] Connection closed with code ${code} (${reason}). Not reconnecting.`);\n            return;\n          }\n\n          this.scheduleReconnect();\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Perform cryptographic handshake\n   */\n  private async performHandshake(): Promise<void> {\n    if (!this.ws || this.ws.readyState !== 1) {\n      throw new Error('WebSocket not connected');\n    }\n\n    console.log('[Client] Starting handshake...');\n    const ephemeralKey = generateEphemeralKeyPair();\n    const { message, state } = createHandshakeInit(this.identityKey, ephemeralKey);\n    this.handshakeState = state;\n\n    // Wait for handshake response response BEFORE sending the init\n    return new Promise((resolve, reject) => {\n      let cleanup: () => void;\n      const ws = this.ws!;\n\n      const timeout = setTimeout(() => {\n        console.error('[Client] Handshake timeout - no response received after 10 seconds');\n        cleanup();\n        reject(new Error('Handshake timeout'));\n      }, 10000);\n\n      const messageHandler = async (data: Buffer) => {\n        try {\n          console.log(`[Client] Received handshake response (${data.length} bytes)`);\n          cleanup();\n\n          const { rootKey } = await processHandshakeResponse(\n            new Uint8Array(data),\n            this.handshakeState!\n          );\n\n          console.log('[Client] Handshake response processed');\n          const ratchetState = createRatchetState();\n          initializeRatchet(ratchetState, { key: rootKey }, ephemeralKey);\n          this.ratchetStates.set('server', ratchetState);\n\n          // Handshake is confirmed implicitly by successful processing\n          // No need to create/send explicit confirmation message as it would be rejected as invalid data\n\n          console.log('[Client] Handshake complete');\n          resolve();\n        } catch (error) {\n          cleanup();\n          console.error('[Client] Handshake error:', error);\n          reject(error);\n        }\n      };\n\n      const closeHandler = (code: number, reason: string) => {\n        cleanup();\n        reject(new Error(`WebSocket closed during handshake: ${code} ${reason}`));\n      };\n\n      const errorHandler = (error: Error) => {\n        cleanup();\n        reject(new Error(`WebSocket error during handshake: ${error.message}`));\n      };\n\n      cleanup = () => {\n        clearTimeout(timeout);\n        ws.removeListener('message', messageHandler);\n        ws.removeListener('close', closeHandler);\n        ws.removeListener('error', errorHandler);\n      };\n\n      // Set up the message handler FIRST\n      ws.on('message', messageHandler);\n      ws.on('close', closeHandler);\n      ws.on('error', errorHandler);\n\n      // Then send handshake init\n      console.log(`[Client] Sending handshake init (${message.length} bytes)...`);\n      ws.send(message);\n    });\n  }\n\n\n\n  /**\n  /**\n   * Handle incoming message from WebSocket\n   * \n   * Routes messages based on size and structure:\n   * - Acknowledgment (25 bytes): Resolves the Promise for the sent message\n   * - Encrypted Message (> 20 bytes): Forwards to the onMessage callback\n   * \n   * @param data - Raw message data from WebSocket\n   */\n  private async handleMessage(data: Buffer | ArrayBuffer | Buffer[]): Promise<void> {\n    const buffer = data instanceof Buffer\n      ? data\n      : Buffer.from(data as ArrayBuffer); // Handle various input types\n\n    // Check for Ack (25 bytes)\n    // 16 (msgId) + 8 (timestamp) + 1 (status)\n    if (buffer.length === 25) {\n      const messageId = buffer.slice(0, 16);\n      // const timestamp = buffer.readBigUInt64LE(16);\n      const status = buffer[24];\n\n      const messageIdHex = messageId.toString('hex');\n      const waiter = this.ackWaiters.get(messageIdHex);\n\n      if (waiter) {\n        waiter(status === 1);\n        this.ackWaiters.delete(messageIdHex);\n      }\n      return;\n    }\n\n    // Encrypted Message (forwarded)\n    // Structure: messageId(16) + headerLen(4) + header + ...\n    if (buffer.length > 20) {\n      const senderId = 'unknown'; // In a real system, the server would wrap the message with sender info\n      // For this P2P/Relay demo, we just pass the raw buffer to the application callback\n      // The application will need to try to decrypt it with known sessions\n\n      this.config.onMessage?.(senderId, new Uint8Array(buffer));\n    }\n  }\n\n  /**\n   * Send a message to a recipient\n   */\n  async sendMessage(recipientId: string, plaintext: string | Uint8Array): Promise<void> {\n    const plaintextBytes = typeof plaintext === 'string'\n      ? new TextEncoder().encode(plaintext)\n      : plaintext;\n\n    // Get or create ratchet state for recipient\n    let ratchetState = this.ratchetStates.get(recipientId);\n    if (!ratchetState) {\n      ratchetState = createRatchetState();\n      // In production, initialize with recipient's public key from directory\n      // For now, create empty state\n      this.ratchetStates.set(recipientId, ratchetState);\n    }\n\n    // Encrypt message\n    const encryptedData = await encryptMessage(plaintextBytes, ratchetState);\n\n    // Queue message for delivery\n    const queuedMessage: QueuedMessage = {\n      messageId: encryptedData.messageId,\n      recipientId,\n      encryptedData,\n      timestamp: Date.now(),\n      retryCount: 0,\n      nextRetry: Date.now(),\n    };\n\n    this.messageQueue.push(queuedMessage);\n\n    // Try to send immediately if connected\n    if (this.connected) {\n      await this.sendQueuedMessage(queuedMessage);\n    }\n  }\n\n  /**\n   * Send a queued message\n   */\n  private async sendQueuedMessage(queued: QueuedMessage): Promise<void> {\n    const ws = this.ws;\n    if (!ws || ws.readyState !== this.WebSocketImpl.OPEN) {\n      return;\n    }\n\n    try {\n      // Serialize message (simplified)\n      const messageBytes = this.serializeMessage(queued.encryptedData);\n      ws.send(messageBytes);\n\n      // Wait for acknowledgment\n      const ackReceived = await new Promise<boolean>((resolve) => {\n        const timeout = setTimeout(() => {\n          resolve(false);\n        }, 5000); // 5 second timeout\n\n        this.ackWaiters.set(\n          Buffer.from(queued.messageId).toString('hex'),\n          (success) => {\n            clearTimeout(timeout);\n            resolve(success);\n          }\n        );\n      });\n\n      if (ackReceived) {\n        // Remove from queue\n        const index = this.messageQueue.indexOf(queued);\n        if (index > -1) {\n          this.messageQueue.splice(index, 1);\n        }\n      } else {\n        // Retry with exponential backoff\n        queued.retryCount++;\n        queued.nextRetry = Date.now() + Math.min(\n          this.retryBackoff * Math.pow(2, queued.retryCount),\n          60000 // Max 1 minute\n        );\n      }\n    } catch (error) {\n      this.config.onError?.(error as Error);\n      // Schedule retry\n      queued.retryCount++;\n      queued.nextRetry = Date.now() + this.retryBackoff;\n    }\n  }\n\n  /**\n   * Serialize message for transmission\n   */\n  private serializeMessage(encryptedData: EncryptedMessageData): Uint8Array {\n    // Simplified serialization\n    // In production, use protobuf\n    const buffer = new Uint8Array(\n      16 + // messageId\n      4 +  // header length\n      encryptedData.header.length +\n      4 +  // ciphertext length\n      encryptedData.ciphertext.length +\n      4 +  // mac length\n      encryptedData.mac.length +\n      8 +  // timestamp\n      4    // version\n    );\n\n    let offset = 0;\n    buffer.set(encryptedData.messageId, offset);\n    offset += 16;\n\n    const headerLenView = new DataView(buffer.buffer, offset, 4);\n    headerLenView.setUint32(0, encryptedData.header.length, false);\n    offset += 4;\n    buffer.set(encryptedData.header, offset);\n    offset += encryptedData.header.length;\n\n    const ciphertextLenView = new DataView(buffer.buffer, offset, 4);\n    ciphertextLenView.setUint32(0, encryptedData.ciphertext.length, false);\n    offset += 4;\n    buffer.set(encryptedData.ciphertext, offset);\n    offset += encryptedData.ciphertext.length;\n\n    const macLenView = new DataView(buffer.buffer, offset, 4);\n    macLenView.setUint32(0, encryptedData.mac.length, false);\n    offset += 4;\n    buffer.set(encryptedData.mac, offset);\n    offset += encryptedData.mac.length;\n\n    const timestampView = new DataView(buffer.buffer, offset, 8);\n    timestampView.setBigUint64(0, BigInt(encryptedData.timestamp), false);\n    offset += 8;\n\n    const versionView = new DataView(buffer.buffer, offset, 4);\n    versionView.setUint32(0, encryptedData.version, false);\n\n    return buffer;\n  }\n\n  /**\n   * Process message queue (send pending messages)\n   */\n  private processMessageQueue(): void {\n    const now = Date.now();\n    const readyMessages = this.messageQueue.filter(\n      (msg) => msg.nextRetry <= now && msg.retryCount < 10 // Max 10 retries\n    );\n\n    for (const msg of readyMessages) {\n      this.sendQueuedMessage(msg).catch((error) => {\n        this.config.onError?.(error);\n      });\n    }\n  }\n\n  /**\n   * Schedule reconnection attempt\n   */\n  private scheduleReconnect(): void {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n\n    this.reconnectTimer = setTimeout(() => {\n      this.connect().catch((error) => {\n        this.config.onError?.(error);\n        this.retryBackoff = Math.min(this.retryBackoff * 2, 60000); // Max 1 minute\n        this.scheduleReconnect();\n      });\n    }, this.retryBackoff);\n  }\n\n  /**\n   * Disconnect from server\n   */\n  disconnect(): void {\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n\n    // Clean up ratchet states\n    for (const state of this.ratchetStates.values()) {\n      cleanupRatchet(state);\n    }\n    this.ratchetStates.clear();\n\n    this.connected = false;\n  }\n\n  /**\n   * Get connection status\n   */\n  isConnected(): boolean {\n    return this.connected && this.ws?.readyState === this.WebSocketImpl?.OPEN;\n  }\n\n  getIdentityPublicKey(): Uint8Array {\n    return this.identityKey.publicKey;\n  }\n}\n\n", "/**\r\n * Key generation and management\r\n * \r\n * Uses audited cryptographic libraries (@noble/curves, @noble/hashes)\r\n * All operations are constant-time where possible.\r\n */\r\n\r\nimport { ed25519 } from '@noble/curves/ed25519';\r\nimport { x25519 } from '@noble/curves/ed25519';\r\nimport { randomBytes } from '@noble/hashes/utils';\r\nimport type {\r\n  IdentityKeyPair,\r\n  EphemeralKeyPair,\r\n  PrivateKey,\r\n  PublicKey,\r\n} from './types.js';\r\nimport { CRYPTO_CONSTANTS, secureZeroMemory } from './constants.js';\r\n\r\n/**\r\n * Generate a new Ed25519 identity key pair\r\n * \r\n * This is a long-term key used for identity and signing.\r\n * Must be stored securely (OS secure enclave when available).\r\n */\r\nexport function generateIdentityKeyPair(): IdentityKeyPair {\r\n  // Ed25519 private key is 32 bytes (seed)\r\n  const seed = randomBytes(CRYPTO_CONSTANTS.IDENTITY_KEY_SIZE);\r\n  const publicKey = ed25519.getPublicKey(seed);\r\n  \r\n  // Ed25519 private key format: seed || publicKey (64 bytes)\r\n  const privateKey = new Uint8Array(CRYPTO_CONSTANTS.IDENTITY_PRIVATE_KEY_SIZE);\r\n  privateKey.set(seed, 0);\r\n  privateKey.set(publicKey, CRYPTO_CONSTANTS.IDENTITY_KEY_SIZE);\r\n  \r\n  // Zero the seed copy (privateKey still contains it)\r\n  secureZeroMemory(seed);\r\n  \r\n  return {\r\n    publicKey,\r\n    privateKey,\r\n  };\r\n}\r\n\r\n/**\r\n * Generate a new X25519 ephemeral key pair\r\n * \r\n * Used for key exchange in handshakes.\r\n * Ephemeral keys should be discarded after use.\r\n */\r\nexport function generateEphemeralKeyPair(): EphemeralKeyPair {\r\n  // X25519 private key is 32 bytes\r\n  const privateKey = randomBytes(CRYPTO_CONSTANTS.EPHEMERAL_KEY_SIZE);\r\n  const publicKey = x25519.getPublicKey(privateKey);\r\n  \r\n  return {\r\n    publicKey,\r\n    privateKey,\r\n  };\r\n}\r\n\r\n/**\r\n * Derive X25519 public key from private key\r\n */\r\nexport function derivePublicKey(privateKey: PrivateKey): PublicKey {\r\n  if (privateKey.length !== CRYPTO_CONSTANTS.EPHEMERAL_KEY_SIZE) {\r\n    throw new Error('Invalid private key size');\r\n  }\r\n  return x25519.getPublicKey(privateKey);\r\n}\r\n\r\n/**\r\n * Compute X25519 shared secret\r\n * \r\n * Returns the shared secret from ECDH key exchange.\r\n * Must be used with HKDF before use as a key.\r\n */\r\nexport function computeSharedSecret(\r\n  privateKey: PrivateKey,\r\n  publicKey: PublicKey\r\n): Uint8Array {\r\n  if (privateKey.length !== CRYPTO_CONSTANTS.EPHEMERAL_KEY_SIZE) {\r\n    throw new Error('Invalid private key size');\r\n  }\r\n  if (publicKey.length !== CRYPTO_CONSTANTS.EPHEMERAL_KEY_SIZE) {\r\n    throw new Error('Invalid public key size');\r\n  }\r\n  \r\n  try {\r\n    return x25519.getSharedSecret(privateKey, publicKey);\r\n  } catch (error) {\r\n    throw new Error(`Shared secret computation failed: ${error}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Sign data with Ed25519\r\n */\r\nexport function sign(\r\n  privateKey: PrivateKey,\r\n  message: Uint8Array\r\n): Uint8Array {\r\n  if (privateKey.length !== CRYPTO_CONSTANTS.IDENTITY_PRIVATE_KEY_SIZE) {\r\n    throw new Error('Invalid private key size for signing');\r\n  }\r\n  \r\n  // Extract seed (first 32 bytes)\r\n  const seed = privateKey.slice(0, CRYPTO_CONSTANTS.IDENTITY_KEY_SIZE);\r\n  return ed25519.sign(message, seed);\r\n}\r\n\r\n/**\r\n * Verify Ed25519 signature\r\n */\r\nexport function verify(\r\n  publicKey: PublicKey,\r\n  message: Uint8Array,\r\n  signature: Uint8Array\r\n): boolean {\r\n  if (publicKey.length !== CRYPTO_CONSTANTS.IDENTITY_KEY_SIZE) {\r\n    throw new Error('Invalid public key size');\r\n  }\r\n  \r\n  try {\r\n    return ed25519.verify(signature, message, publicKey);\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Generate random nonce\r\n */\r\nexport function generateNonce(): Uint8Array {\r\n  return randomBytes(CRYPTO_CONSTANTS.NONCE_SIZE);\r\n}\r\n\r\n/**\r\n * Generate random message ID\r\n */\r\nexport function generateMessageId(): Uint8Array {\r\n  return randomBytes(CRYPTO_CONSTANTS.MESSAGE_ID_SIZE);\r\n}\r\n\r\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha512';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { ExtPointType, twistedEdwards } from './abstract/edwards.js';\nimport { montgomery } from './abstract/montgomery.js';\nimport { Field, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.js';\nimport {\n  bytesToHex,\n  bytesToNumberLE,\n  ensureBytes,\n  equalBytes,\n  Hex,\n  numberToBytesLE,\n} from './abstract/utils.js';\nimport { createHasher, htfBasicOpts, expand_message_xmd } from './abstract/hash-to-curve.js';\nimport { AffinePoint } from './abstract/curve.js';\n\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\n\nconst ED25519_P = BigInt(\n  '57896044618658097711785492504343953926634992332820282019728792003956564819949'\n);\n// \u221A(-1) aka \u221A(a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5);\n// prettier-ignore\nconst _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  const P = ED25519_P;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ED25519_P;\n  const v3 = mod(v * v * v, P); // v\u00B3\n  const v7 = mod(v3 * v3 * v, P); // v\u2077\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv\u00B3)(uv\u2077)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx\u00B2\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx\u00B2 = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx\u00B2 = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx\u00B2 = -u\u221A(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\n// Just in case\nexport const ED25519_TORSION_SUBGROUP = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n\nconst Fp = Field(ED25519_P, undefined, true);\n\nconst ed25519Defaults = {\n  // Param: a\n  a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n  // d is equal to -121665/121666 over finite field.\n  // Negative number is P - number, and division is invert(number, P)\n  d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n  // Finite field \uD835\uDD3Dp over which we'll do calculations; 2n**255n - 19n\n  Fp,\n  // Subgroup order: how many points curve has\n  // 2n**252n + 27742317777372353535851937790883648493n;\n  n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n  // Cofactor\n  h: BigInt(8),\n  // Base point (x, y) aka generator point\n  Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n  Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n  hash: sha512,\n  randomBytes,\n  adjustScalarBytes,\n  // dom2\n  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n  // Constant-time, u/\u221Av\n  uvRatio,\n} as const;\n\nexport const ed25519 = /* @__PURE__ */ twistedEdwards(ed25519Defaults);\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    utf8ToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nexport const ed25519ctx = /* @__PURE__ */ twistedEdwards({\n  ...ed25519Defaults,\n  domain: ed25519_domain,\n});\nexport const ed25519ph = /* @__PURE__ */ twistedEdwards({\n  ...ed25519Defaults,\n  domain: ed25519_domain,\n  prehash: sha512,\n});\n\nexport const x25519 = /* @__PURE__ */ (() =>\n  montgomery({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x: bigint): bigint => {\n      const P = ED25519_P;\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, BigInt(3), P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n  }))();\n\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub: Hex): Uint8Array {\n  const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n  const _1n = BigInt(1);\n  return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv: Uint8Array): Uint8Array {\n  const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n  return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\n\nconst ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic\n\nconst ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1\nconst ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)\nconst ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic\nconst ELL2_J = BigInt(486662);\n\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u: bigint) {\n  let tv1 = Fp.sqr(u);       //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);  //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);      //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);     //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);         //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);         //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);         //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);          //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = FpSqrtEven(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n\n  const inv = Fp.invertBatch([xd, yd]); // batch division\n  return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\n\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519.ExtendedPoint,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\nexport const hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n\nfunction assertRstPoint(other: unknown) {\n  if (!(other instanceof RistPoint)) throw new Error('RistrettoPoint expected');\n}\n\n// \u221A(-1) aka \u221A(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// \u221A(ad - 1)\nconst SQRT_AD_MINUS_ONE = BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / \u221A(a-d)\nconst INVSQRT_A_MINUS_D = BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d\u00B2\nconst ONE_MINUS_D_SQ = BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)\u00B2\nconst D_MINUS_ONE_SQ = BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/\u221A(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes: Uint8Array) =>\n  ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\ntype ExtendedPoint = ExtPointType;\n\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0: bigint): ExtendedPoint {\n  const { d } = ed25519.CURVE;\n  const P = ed25519.CURVE.Fp.ORDER;\n  const mod = ed25519.CURVE.Fp.create;\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n  static BASE: RistPoint;\n  static ZERO: RistPoint;\n  // Private property to discourage combining ExtendedPoint + RistrettoPoint\n  // Always use Ristretto encoding/decoding instead.\n  constructor(private readonly ep: ExtendedPoint) {}\n\n  static fromAffine(ap: AffinePoint<bigint>) {\n    return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n  }\n\n  /**\n   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n   * The hash-to-group operation applies Elligator twice and adds the results.\n   * **Note:** this is one-way map, there is no conversion from point to hash.\n   * https://ristretto.group/formulas/elligator.html\n   * @param hex 64-byte output of a hash function\n   */\n  static hashToCurve(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHash', hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new RistPoint(R1.add(R2));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * https://ristretto.group/formulas/decoding.html\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHex', hex, 32);\n    const { a, d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n) throw new Error(emsg);\n    return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * https://ristretto.group/formulas/encoding.html\n   */\n  toRawBytes(): Uint8Array {\n    let { ex: x, ey: y, ez: z, et: t } = this.ep;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const u1 = mod(mod(z + y) * mod(z - y)); // 1\n    const u2 = mod(x * y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * t); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(t * zInv, P)) {\n      let _x = mod(y * SQRT_M1);\n      let _y = mod(x * SQRT_M1);\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(x * zInv, P)) y = mod(-y); // 9\n    let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return numberToBytesLE(s, 32); // 11\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  // Compare one point to another.\n  equals(other: RistPoint): boolean {\n    assertRstPoint(other);\n    const { ex: X1, ey: Y1 } = this.ep;\n    const { ex: X2, ey: Y2 } = other.ep;\n    const mod = ed25519.CURVE.Fp.create;\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  add(other: RistPoint): RistPoint {\n    assertRstPoint(other);\n    return new RistPoint(this.ep.add(other.ep));\n  }\n\n  subtract(other: RistPoint): RistPoint {\n    assertRstPoint(other);\n    return new RistPoint(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiplyUnsafe(scalar));\n  }\n}\nexport const RistrettoPoint = /* @__PURE__ */ (() => {\n  if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n  if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n  return RistPoint;\n})();\n\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nexport const hashToRistretto255 = (msg: Uint8Array, options: htfBasicOpts) => {\n  const d = options.DST;\n  const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n  const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n  const P = RistPoint.hashToCurve(uniform_bytes);\n  return P;\n};\nexport const hash_to_ristretto255 = hashToRistretto255; // legacy\n", "import { SHA2 } from './_sha2.js';\nimport u64 from './_u64.js';\nimport { wrapConstructor } from './utils.js';\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends SHA2<SHA512> {\n  // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n  // Also looks cleaner and easier to verify with spec.\n  // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x6a09e667 | 0;\n  Al = 0xf3bcc908 | 0;\n  Bh = 0xbb67ae85 | 0;\n  Bl = 0x84caa73b | 0;\n  Ch = 0x3c6ef372 | 0;\n  Cl = 0xfe94f82b | 0;\n  Dh = 0xa54ff53a | 0;\n  Dl = 0x5f1d36f1 | 0;\n  Eh = 0x510e527f | 0;\n  El = 0xade682d1 | 0;\n  Fh = 0x9b05688c | 0;\n  Fl = 0x2b3e6c1f | 0;\n  Gh = 0x1f83d9ab | 0;\n  Gl = 0xfb41bd6b | 0;\n  Hh = 0x5be0cd19 | 0;\n  Hl = 0x137e2179 | 0;\n\n  constructor() {\n    super(128, 64, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ) {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number) {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean() {\n    SHA512_W_H.fill(0);\n    SHA512_W_L.fill(0);\n  }\n  destroy() {\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nclass SHA512_224 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x8c3d37c8 | 0;\n  Al = 0x19544da2 | 0;\n  Bh = 0x73e19966 | 0;\n  Bl = 0x89dcd4d6 | 0;\n  Ch = 0x1dfab7ae | 0;\n  Cl = 0x32ff9c82 | 0;\n  Dh = 0x679dd514 | 0;\n  Dl = 0x582f9fcf | 0;\n  Eh = 0x0f6d2b69 | 0;\n  El = 0x7bd44da8 | 0;\n  Fh = 0x77e36f73 | 0;\n  Fl = 0x04c48942 | 0;\n  Gh = 0x3f9d85a8 | 0;\n  Gl = 0x6a1d36c8 | 0;\n  Hh = 0x1112e6ad | 0;\n  Hl = 0x91d692a1 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\nclass SHA512_256 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0x22312194 | 0;\n  Al = 0xfc2bf72c | 0;\n  Bh = 0x9f555fa3 | 0;\n  Bl = 0xc84c64c2 | 0;\n  Ch = 0x2393b86b | 0;\n  Cl = 0x6f53b151 | 0;\n  Dh = 0x96387719 | 0;\n  Dl = 0x5940eabd | 0;\n  Eh = 0x96283ee2 | 0;\n  El = 0xa88effe3 | 0;\n  Fh = 0xbe5e1e25 | 0;\n  Fl = 0x53863992 | 0;\n  Gh = 0x2b0199fc | 0;\n  Gl = 0x2c85b8aa | 0;\n  Hh = 0x0eb72ddc | 0;\n  Hl = 0x81c52ca2 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 32;\n  }\n}\n\nclass SHA384 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  Ah = 0xcbbb9d5d | 0;\n  Al = 0xc1059ed8 | 0;\n  Bh = 0x629a292a | 0;\n  Bl = 0x367cd507 | 0;\n  Ch = 0x9159015a | 0;\n  Cl = 0x3070dd17 | 0;\n  Dh = 0x152fecd8 | 0;\n  Dl = 0xf70e5939 | 0;\n  Eh = 0x67332667 | 0;\n  El = 0xffc00b31 | 0;\n  Fh = 0x8eb44a87 | 0;\n  Fl = 0x68581511 | 0;\n  Gh = 0xdb0c2e0d | 0;\n  Gl = 0x64f98fa7 | 0;\n  Hh = 0x47b5481d | 0;\n  Hl = 0xbefa4fa4 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 48;\n  }\n}\n\nexport const sha512 = /* @__PURE__ */ wrapConstructor(() => new SHA512());\nexport const sha512_224 = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\nexport const sha512_256 = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\nexport const sha384 = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n", "import { exists, output } from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n", "function number(n: number) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(`Wrong positive integer: ${n}`);\n}\n\nfunction bool(b: boolean) {\n  if (typeof b !== 'boolean') throw new Error(`Expected boolean, not ${b}`);\n}\n\n// copied from utils\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\nfunction bytes(b: Uint8Array | undefined, ...lengths: number[]) {\n  if (!isBytes(b)) throw new Error('Expected Uint8Array');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\n\ntype Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\nfunction hash(hash: Hash) {\n  if (typeof hash !== 'function' || typeof hash.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(hash.outputLen);\n  number(hash.blockLen);\n}\n\nfunction exists(instance: any, checkFinished = true) {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nfunction output(out: any, instance: any) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\nexport { number, bool, bytes, hash, exists, output };\n\nconst assert = { number, bool, bytes, hash, exists, output };\nexport default assert;\n", "/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return (\n    a instanceof Uint8Array ||\n    (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array')\n  );\n}\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n// Other libraries would silently corrupt the data instead of throwing an error,\n// when they don't support it.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!isBytes(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 } as const;\nfunction asciiToBase16(char: number): number | undefined {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!isBytes(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    if (!isBytes(a)) throw new Error('Uint8Array expected');\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\nconst toStr = {}.toString;\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// See utils.ts for details.\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n: bigint, le = false) {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false) {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number) => h >>> s;\nconst shrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number) => l;\nconst rotr32L = (h: number, _l: number) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number) => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah: number, Al: number, Bh: number, Bl: number) {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number) =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number) =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number) =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64 = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2\nimport { mod } from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes, FHash, Hex } from './utils.js';\nimport { Group, GroupConstructor, wNAF, BasicCurve, validateBasic, AffinePoint } from './curve.js';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n// Edwards curves must declare params a & d.\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: (u: bigint, v: bigint) => { isValid: boolean; value: bigint }; // Ratio \u221A(u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    curve,\n    {\n      hash: 'function',\n      a: 'bigint',\n      d: 'bigint',\n      randomBytes: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      uvRatio: 'function',\n      mapToCurve: 'function',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...opts } as const);\n}\n\n// Instance of Extended Point with coordinates in X, Y, Z, T\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n}\n// Static methods of Extended Point with coordinates in X, Y, Z, T\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromHex(hex: Hex): ExtPointType;\n  fromPrivateKey(privateKey: Hex): ExtPointType;\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n  };\n};\n\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nexport function twistedEdwards(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor,\n  } = CURVE;\n  const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n  const modP = Fp.create; // Function overrides\n\n  // sqrt(u/v)\n  const uvRatio =\n    CURVE.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    CURVE.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n  const inBig = (n: bigint) => typeof n === 'bigint' && _0n < n; // n in [1..]\n  const inRange = (n: bigint, max: bigint) => inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n  const in0MaskRange = (n: bigint) => n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n  function assertInRange(n: bigint, max: bigint) {\n    // n in [1..max-1]\n    if (inRange(n, max)) return n;\n    throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n  }\n  function assertGE0(n: bigint) {\n    // n in [0..CURVE_ORDER-1]\n    return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n  }\n  const pointPrecomputes = new Map<Point, Point[]>();\n  function isPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Extended Point works in extended coordinates: (x, y, z, t) \u220B (x=x/z, y=y/z, t=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n\n    constructor(\n      readonly ex: bigint,\n      readonly ey: bigint,\n      readonly ez: bigint,\n      readonly et: bigint\n    ) {\n      if (!in0MaskRange(ex)) throw new Error('x required');\n      if (!in0MaskRange(ey)) throw new Error('y required');\n      if (!in0MaskRange(ez)) throw new Error('z required');\n      if (!in0MaskRange(et)) throw new Error('t required');\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      if (!in0MaskRange(x) || !in0MaskRange(y)) throw new Error('invalid affine point');\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.ez));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    _WINDOW_SIZE?: number;\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      const { a, d } = CURVE;\n      if (this.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n      // Equation in affine coordinates: ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2\n      // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX\u00B2 + Y\u00B2)Z\u00B2 = Z\u2074 + dX\u00B2Y\u00B2\n      const { ex: X, ey: Y, ez: Z, et: T } = this;\n      const X2 = modP(X * X); // X\u00B2\n      const Y2 = modP(Y * Y); // Y\u00B2\n      const Z2 = modP(Z * Z); // Z\u00B2\n      const Z4 = modP(Z2 * Z2); // Z\u2074\n      const aX2 = modP(X2 * a); // aX\u00B2\n      const left = modP(Z2 * modP(aX2 + Y2)); // (aX\u00B2 + Y\u00B2)Z\u00B2\n      const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z\u2074 + dX\u00B2Y\u00B2\n      if (left !== right) throw new Error('bad point: equation left != right (1)');\n      // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n      const XY = modP(X * Y);\n      const ZT = modP(Z * T);\n      if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      isPoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    protected is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      isPoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      // Faster algo for adding 2 Extended Points when curve's a=-1.\n      // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n      // Cost: 8M + 8add + 2*2.\n      // Note: It does not check whether the `other` point is valid.\n      if (a === BigInt(-1)) {\n        const A = modP((Y1 - X1) * (Y2 + X2));\n        const B = modP((Y1 + X1) * (Y2 - X2));\n        const F = modP(B - A);\n        if (F === _0n) return this.double(); // Same point. Tests say it doesn't affect timing\n        const C = modP(Z1 * _2n * T2);\n        const D = modP(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = modP(E * F);\n        const Y3 = modP(G * H);\n        const T3 = modP(E * H);\n        const Z3 = modP(F * G);\n        return new Point(X3, Y3, Z3, T3);\n      }\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    multiplyUnsafe(scalar: bigint): Point {\n      let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n      if (n === _0n) return I;\n      if (this.equals(I) || n === _1n) return this;\n      if (this.equals(G)) return this.wNAF(n).p;\n      return wnaf.unsafeLadder(this, n);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz?: bigint): AffinePoint<bigint> {\n      const { ex: x, ey: y, ez: z } = this;\n      const is0 = this.is0();\n      if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n      const ax = modP(x * iz);\n      const ay = modP(y * iz);\n      const zz = modP(z * iz);\n      if (is0) return { x: _0n, y: _1n };\n      if (zz !== _1n) throw new Error('invZ was invalid');\n      return { x: ax, y: ay };\n    }\n\n    clearCofactor(): Point {\n      const { h: cofactor } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = ut.bytesToNumberLE(normed);\n      if (y === _0n) {\n        // y=0 is allowed\n      } else {\n        // RFC8032 prohibits >= p, but ZIP215 doesn't\n        if (zip215) assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n        else assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n      }\n\n      // Ed25519: x\u00B2 = (y\u00B2-1)/(dy\u00B2+1) mod p. Ed448: x\u00B2 = (y\u00B2-1)/(dy\u00B2-1) mod p. Generic case:\n      // ax\u00B2+y\u00B2=1+dx\u00B2y\u00B2 => y\u00B2-1=dx\u00B2y\u00B2-ax\u00B2 => y\u00B2-1=x\u00B2(dy\u00B2-a) => x\u00B2=(y\u00B2-1)/(dy\u00B2-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y\u00B2 - 1\n      const v = modP(d * y2 - a); // v = d y\u00B2 + 1.\n      let { isValid, value: x } = uvRatio(u, v); // \u221A(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateKey(privKey: Hex) {\n      return getExtendedPublicKey(privKey).point;\n    }\n    toRawBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex(): string {\n      return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  const { BASE: G, ZERO: I } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return modN(ut.bytesToNumberLE(hash));\n  }\n\n  /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n  function getExtendedPublicKey(key: Hex) {\n    const len = nByteLength;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = new Uint8Array(), ...msgs: Uint8Array[]) {\n    const msg = ut.concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    assertGE0(s); // 0 <= s < l\n    const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, nByteLength * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n    // zip215: true is good for consensus-critical apps and allows points < 2^256\n    // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n    let A, R, SB;\n    try {\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n    randomPrivateKey: (): Uint8Array => randomBytes(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    },\n  };\n\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils,\n  };\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport {\n  bitMask,\n  numberToBytesBE,\n  numberToBytesLE,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  validateObject,\n} from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n// Inverses number over modulo\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) \u2261 1    if a is a square (mod p)\n  // (a | p) \u2261 -1   if a is not a square (mod p)\n  // (a | p) \u2261 0    if a \u2261 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p) \u2261 -1 and set c \u2261 zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be \u2261 -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\nexport function FpSqrt(P: bigint) {\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n\n  // P \u2261 3 (mod 4)\n  // \u221An = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q \u2261 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P \u2261 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint) => (mod(num, modulo) & _1n) === _1n;\n\n// Field is not always over prime: for example, Fp2 has ORDER(q)=p^m\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('Expected power > 0');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>) {\n  const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n  return (x: T): boolean => {\n    const p = f.pow(x, legendreConst);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');\n  const sqrtP = FpSqrt(ORDER);\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n  const num = isLE ? bytesToNumberBE(key) : bytesToNumberLE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (u8a(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\nexport function equalBytes(b1: Uint8Array, b2: Uint8Array) {\n  // We don't care about timing attacks here\n  if (b1.length !== b2.length) return false;\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\n  return true;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number) {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n: bigint, pos: number, value: boolean) => {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\n\n// DRBG\n\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any) => typeof val === 'bigint',\n  function: (val: any) => typeof val === 'function',\n  boolean: (val: any) => typeof val === 'boolean',\n  string: (val: any) => typeof val === 'string',\n  stringOrUint8Array: (val: any) => typeof val === 'string' || val instanceof Uint8Array,\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\n  array: (val: any) => Array.isArray(val),\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n) {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function')\n      throw new Error(`Invalid validator \"${type}\", expected function`);\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        `Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\nimport { IField, validateField, nLength } from './modular.js';\nimport { validateObject } from './utils.js';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / \uD835\uDC4A) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number) {\n  const constTimeNegate = (condition: boolean, item: T): T => {\n    const neg = item.negate();\n    return condition ? neg : item;\n  };\n  const opts = (W: number) => {\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n  };\n  return {\n    constTimeNegate,\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint) {\n      let p = c.ZERO;\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(\uD835\uDC4A\u22121) * (Math.ceil(\uD835\uDC5B / \uD835\uDC4A) + 1), where:\n     * - \uD835\uDC4A is the window size\n     * - \uD835\uDC5B is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = opts(W);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const { windows, windowSize } = opts(W);\n\n      let p = c.ZERO;\n      let f = c.BASE;\n\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n\n        // Shift number by W bits.\n        n >>= shiftBy;\n\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    wNAFCached(P: T, precomputesMap: Map<T, T[]>, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      // @ts-ignore\n      const W: number = P._WINDOW_SIZE || 1;\n      // Calculate precomputes on a first run, reuse them after\n      let comp = precomputesMap.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) {\n          precomputesMap.set(P, transform(comp));\n        }\n      }\n      return this.wNAF(W, comp, n);\n    },\n  };\n}\n\n// Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n// Though generator can be different (Fp2 / Fp6 for BLS).\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(curve: BasicCurve<FP> & T) {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n", "/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod, pow } from './modular.js';\nimport { bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject } from './utils.js';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  nByteLength: number;\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array;\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  a: bigint;\n  montgomeryBits: number;\n  powPminus2?: (x: bigint) => bigint;\n  xyToU?: (x: bigint, y: bigint) => bigint;\n  Gu: bigint;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\nexport type CurveFn = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  utils: { randomPrivateKey: () => Uint8Array };\n  GuBytes: Uint8Array;\n};\n\nfunction validateOpts(curve: CurveType) {\n  validateObject(\n    curve,\n    {\n      a: 'bigint',\n    },\n    {\n      montgomeryBits: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      powPminus2: 'function',\n      Gu: 'bigint',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...curve } as const);\n}\n\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef);\n  const { P } = CURVE;\n  const modP = (n: bigint) => mod(n, P);\n  const montgomeryBits = CURVE.montgomeryBits;\n  const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n  const fieldLen = CURVE.nByteLength;\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes);\n  const powPminus2 = CURVE.powPminus2 || ((x: bigint) => pow(x, P - BigInt(2), P));\n\n  // cswap from RFC7748. But it is not from RFC7748!\n  /*\n    cswap(swap, x_2, x_3):\n         dummy = mask(swap) AND (x_2 XOR x_3)\n         x_2 = x_2 XOR dummy\n         x_3 = x_3 XOR dummy\n         Return (x_2, x_3)\n  Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n   and x_3, computed, e.g., as mask(swap) = 0 - swap.\n  */\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): [bigint, bigint] {\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy);\n    x_3 = modP(x_3 + dummy);\n    return [x_2, x_3];\n  }\n\n  // Accepts 0 as well\n  function assertFieldElement(n: bigint): bigint {\n    if (typeof n === 'bigint' && _0n <= n && n < P) return n;\n    throw new Error('Expected valid scalar 0 < scalar < CURVE.P');\n  }\n\n  // x25519 from 4\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n  /**\n   *\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(pointU: bigint, scalar: bigint): bigint {\n    const u = assertFieldElement(pointU);\n    // Section 5: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.\n    const k = assertFieldElement(scalar);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw: [bigint, bigint];\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      sw = cswap(swap, x_2, x_3);\n      x_2 = sw[0];\n      x_3 = sw[1];\n      sw = cswap(swap, z_2, z_3);\n      z_2 = sw[0];\n      z_3 = sw[1];\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    // (x_2, x_3) = cswap(swap, x_2, x_3)\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    // (z_2, z_3) = cswap(swap, z_2, z_3)\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    // z_2^(p - 2)\n    const z2 = powPminus2(z_2);\n    // Return x_2 * (z_2^(p - 2))\n    return modP(x_2 * z2);\n  }\n\n  function encodeUCoordinate(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), montgomeryBytes);\n  }\n\n  function decodeUCoordinate(uEnc: Hex): bigint {\n    // Section 5: When receiving such an array, implementations of X25519\n    // MUST mask the most significant bit in the final byte.\n    // This is very ugly way, but it works because fieldLen-1 is outside of bounds for X448, so this becomes NOOP\n    // fieldLen - scalaryBytes = 1 for X448 and = 0 for X25519\n    const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n    // u[fieldLen-1] crashes QuickJS (TypeError: out-of-bound numeric index)\n    if (fieldLen === montgomeryBytes) u[fieldLen - 1] &= 127; // 0b0111_1111\n    return bytesToNumberLE(u);\n  }\n  function decodeScalar(n: Hex): bigint {\n    const bytes = ensureBytes('scalar', n);\n    if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen)\n      throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes.length}`);\n    return bytesToNumberLE(adjustScalarBytes(bytes));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pointU = decodeUCoordinate(u);\n    const _scalar = decodeScalar(scalar);\n    const pu = montgomeryLadder(pointU, _scalar);\n    // The result was not contributory\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('Invalid private or public key received');\n    return encodeUCoordinate(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  const GuBytes = encodeUCoordinate(CURVE.Gu);\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\n    utils: { randomPrivateKey: () => CURVE.randomBytes!(CURVE.nByteLength) },\n    GuBytes: GuBytes,\n  };\n}\n", "/**\r\n * Cryptographic constants\r\n * \r\n * All sizes are in bytes unless otherwise specified.\r\n */\r\n\r\nexport const CRYPTO_CONSTANTS = {\r\n  // Key sizes\r\n  IDENTITY_KEY_SIZE: 32,        // Ed25519 public key\r\n  IDENTITY_PRIVATE_KEY_SIZE: 64, // Ed25519 private key (seed + public)\r\n  EPHEMERAL_KEY_SIZE: 32,       // X25519 key size\r\n  CHAIN_KEY_SIZE: 32,           // HKDF output size\r\n  ROOT_KEY_SIZE: 32,            // HKDF output size\r\n  MESSAGE_KEY_SIZE: 32,         // AES-256 key size\r\n  MAC_KEY_SIZE: 32,             // HMAC key size\r\n  \r\n  // Nonce and IV sizes\r\n  NONCE_SIZE: 16,               // Random nonce for handshakes\r\n  AES_IV_SIZE: 12,              // AES-GCM IV size\r\n  AES_TAG_SIZE: 16,             // AES-GCM authentication tag\r\n  \r\n  // Message limits\r\n  MAX_MESSAGE_SIZE: 1024 * 1024, // 1 MB max message size\r\n  MAX_CHAIN_LENGTH: 2 ** 32 - 1,  // Max messages per chain\r\n  MAX_SKIPPED_MESSAGES: 1000,     // Max skipped messages to store\r\n  \r\n  // Protocol\r\n  PROTOCOL_VERSION: 1,\r\n  MESSAGE_ID_SIZE: 16,\r\n  \r\n  // Timing\r\n  MESSAGE_EXPIRY_MS: 7 * 24 * 60 * 60 * 1000, // 7 days\r\n  KEY_ROTATION_INTERVAL: 100,                  // Rotate after 100 messages\r\n  MAX_CLOCK_SKEW_MS: 5 * 60 * 1000,           // 5 minutes\r\n  \r\n  // HKDF info strings (domain separation)\r\n  HKDF_ROOT_KEY_INFO: 'SecureMessenger-RootKey',\r\n  HKDF_CHAIN_KEY_INFO: 'SecureMessenger-ChainKey',\r\n  HKDF_MESSAGE_KEY_INFO: 'SecureMessenger-MessageKey',\r\n  HKDF_HANDSHAKE_INFO: 'SecureMessenger-Handshake',\r\n} as const;\r\n\r\n/**\r\n * Secure memory utilities\r\n * Attempts to zero memory (best effort, not guaranteed on all platforms)\r\n */\r\nexport function secureZeroMemory(data: Uint8Array): void {\r\n  // Note: JavaScript/TypeScript cannot guarantee memory zeroing\r\n  // This is best-effort. For production, consider using WebAssembly\r\n  // with explicit memory management or native modules.\r\n  if (data && data.length > 0) {\r\n    crypto.getRandomValues(data);\r\n    data.fill(0);\r\n  }\r\n}\r\n\r\n", "/**\n * Double Ratchet Protocol Implementation\n * \n * Provides forward secrecy and post-compromise security.\n * Based on the Signal Protocol's Double Ratchet.\n * \n * Key properties:\n * - Forward secrecy: Past messages remain secure if keys are compromised\n * - Post-compromise security: Future messages become secure after key update\n * - Out-of-order message handling: Can decrypt messages received out of order\n */\n\nimport type {\n  RatchetState,\n  MessageKey,\n  EphemeralKeyPair,\n  PublicKey,\n} from './types.js';\nimport { CRYPTO_CONSTANTS, secureZeroMemory } from './constants.js';\nimport {\n  computeSharedSecret,\n  generateEphemeralKeyPair,\n} from './keygen.js';\nimport {\n  deriveRootKey,\n  deriveChainKey,\n  deriveMessageKey,\n  hkdf,\n} from './hkdf.js';\n\n/**\n * Initialize a new ratchet state\n */\nexport function createRatchetState(): RatchetState {\n  return {\n    rootKey: { key: new Uint8Array(CRYPTO_CONSTANTS.ROOT_KEY_SIZE) },\n\n    sendCounter: 0,\n    receiveCounter: 0,\n    skippedMessageKeys: new Map(),\n    previousChainLength: 0,\n  };\n}\n\n/**\n * Initialize ratchet from handshake\n * \n * This is called after a successful handshake to set up the initial\n * ratchet state with the derived root key.\n */\nexport function initializeRatchet(\n  state: RatchetState,\n  rootKey: { key: Uint8Array },\n  sendingEphemeralKey?: EphemeralKeyPair,\n  receivingEphemeralPublicKey?: PublicKey\n): void {\n  state.rootKey = rootKey;\n  state.sendCounter = 0;\n  state.receiveCounter = 0;\n\n  if (sendingEphemeralKey !== undefined) {\n    state.sendingEphemeralKey = sendingEphemeralKey;\n  }\n  if (receivingEphemeralPublicKey !== undefined) {\n    state.receivingEphemeralPublicKey = receivingEphemeralPublicKey;\n  }\n\n  const chainKeyBytes = deriveChainKey(state.rootKey.key, 'initial-chain');\n  state.sendingChainKey = { key: chainKeyBytes, index: 0 };\n  state.receivingChainKey = { key: chainKeyBytes, index: 0 };\n\n  state.previousChainLength = 0;\n}\n\n/**\n * Ratchet forward (sending side)\n * \n * Called when sending a message. Derives a new message key and\n * updates the ratchet state.\n */\nexport function ratchetEncrypt(\n  state: RatchetState,\n  plaintext: Uint8Array\n): {\n  messageKey: MessageKey;\n  header: Uint8Array; // Encrypted header containing ratchet info\n  ciphertext: Uint8Array;\n} {\n  // Ensure we have a sending chain\n  if (!state.sendingChainKey) {\n    if (!state.sendingEphemeralKey) {\n      // Generate new ephemeral key pair\n      state.sendingEphemeralKey = generateEphemeralKeyPair();\n    }\n\n    // Derive new chain key from root key\n    const chainKeyBytes = deriveChainKey(\n      state.rootKey.key,\n      `sending-${Date.now()}`\n    );\n    state.sendingChainKey = {\n      key: chainKeyBytes,\n      index: 0,\n    };\n  }\n\n  // Derive message key from chain key\n  const { messageKey: messageKeyBytes, nextChainKey } = deriveMessageKey(\n    state.sendingChainKey!.key\n  );\n\n  // Create message key structure\n  // messageKeyBytes is 32 bytes (encryption key), we need to derive MAC key separately\n  // For now, use HKDF to derive both from messageKeyBytes\n  const macKey = hkdf(messageKeyBytes, null, 'mac-key', 32);\n  const messageKey: MessageKey = {\n    encryptionKey: messageKeyBytes,\n    macKey: macKey,\n    iv: new Uint8Array(CRYPTO_CONSTANTS.AES_IV_SIZE), // Will be generated during encryption\n    index: state.sendingChainKey!.index,\n  };\n\n  // Update chain key\n  state.sendingChainKey = {\n    key: nextChainKey,\n    index: state.sendingChainKey!.index + 1,\n  };\n\n  // Check chain length limit\n  if (state.sendingChainKey!.index >= CRYPTO_CONSTANTS.MAX_CHAIN_LENGTH) {\n    throw new Error('Chain length exceeded, must perform new handshake');\n  }\n\n  // For now, return simplified structure\n  // In full implementation, header would be encrypted separately\n  const header = new Uint8Array(0); // Placeholder\n\n  return {\n    messageKey,\n    header,\n    ciphertext: plaintext, // Placeholder - actual encryption happens in protocol layer\n  };\n}\n\n/**\n * Ratchet forward (receiving side)\n * \n * Called when receiving a message. Updates the ratchet state and\n * derives the message key for decryption.\n */\nexport function ratchetDecrypt(\n  state: RatchetState,\n  dhPublicKey: PublicKey,\n  messageNumber: number,\n  _previousChainLength: number\n): MessageKey {\n  // Check if this is a new DH key (new chain)\n  const isNewChain = !state.receivingEphemeralPublicKey ||\n    !constantTimeEqual(state.receivingEphemeralPublicKey, dhPublicKey);\n\n  if (isNewChain) {\n    // Save previous chain length\n    state.previousChainLength = state.receivingChainKey?.index || 0;\n\n    // Compute new root key and chain key\n    if (!state.sendingEphemeralKey) {\n      throw new Error('Cannot ratchet: no sending ephemeral key');\n    }\n\n    const sharedSecret = computeSharedSecret(\n      state.sendingEphemeralKey.privateKey,\n      dhPublicKey\n    );\n\n    // Derive new root key\n    const rootKeyInput = new Uint8Array(\n      state.rootKey.key.length + sharedSecret.length\n    );\n    rootKeyInput.set(state.rootKey.key, 0);\n    rootKeyInput.set(sharedSecret, state.rootKey.key.length);\n\n    state.rootKey = {\n      key: deriveRootKey(rootKeyInput),\n    };\n\n    // Derive new receiving chain key\n    const chainKeyBytes = deriveChainKey(\n      state.rootKey.key,\n      `receiving-${Date.now()}`\n    );\n    state.receivingChainKey = {\n      key: chainKeyBytes,\n      index: 0,\n    };\n\n    state.receivingEphemeralPublicKey = dhPublicKey;\n\n    // Zero shared secret\n    secureZeroMemory(sharedSecret);\n  }\n\n  // Check if message is from a skipped chain\n  if (messageNumber < state.previousChainLength) {\n    // Try to find in skipped message keys\n    const skippedKey = state.skippedMessageKeys.get(messageNumber);\n    if (skippedKey) {\n      state.skippedMessageKeys.delete(messageNumber);\n      return skippedKey;\n    }\n    throw new Error('Message from old chain, key not available');\n  }\n\n  // Check if message is out of order (future message)\n  if (!state.receivingChainKey) {\n    throw new Error('No receiving chain key available');\n  }\n\n  if (messageNumber > state.receivingChainKey!.index) {\n    // Skip forward to this message number\n    const skipCount = messageNumber - state.receivingChainKey!.index;\n    if (skipCount > CRYPTO_CONSTANTS.MAX_SKIPPED_MESSAGES) {\n      throw new Error('Too many skipped messages');\n    }\n\n    // Derive keys for skipped messages and store them\n    let currentKey = state.receivingChainKey!.key;\n    let currentIndex = state.receivingChainKey!.index;\n\n    while (currentIndex < messageNumber) {\n      const { messageKey: messageKeyBytes, nextChainKey } = deriveMessageKey(\n        currentKey\n      );\n\n      if (currentIndex < messageNumber - 1) {\n        // Store skipped message key\n        const skippedMacKey = hkdf(messageKeyBytes, null, 'mac-key', 32);\n        const skippedKey: MessageKey = {\n          encryptionKey: messageKeyBytes,\n          macKey: skippedMacKey,\n          iv: new Uint8Array(CRYPTO_CONSTANTS.AES_IV_SIZE),\n          index: currentIndex,\n        };\n        state.skippedMessageKeys.set(currentIndex, skippedKey);\n      }\n\n      currentKey = nextChainKey;\n      currentIndex++;\n    }\n\n    state.receivingChainKey = {\n      key: currentKey,\n      index: currentIndex,\n    };\n  }\n\n  // Derive message key for current message\n  const { messageKey: messageKeyBytes, nextChainKey } = deriveMessageKey(\n    state.receivingChainKey!.key\n  );\n\n  // Derive MAC key from encryption key\n  const macKey = hkdf(messageKeyBytes, null, 'mac-key', 32);\n  const messageKey: MessageKey = {\n    encryptionKey: messageKeyBytes,\n    macKey: macKey,\n    iv: new Uint8Array(CRYPTO_CONSTANTS.AES_IV_SIZE),\n    index: state.receivingChainKey!.index,\n  };\n\n  // Update chain key\n  state.receivingChainKey = {\n    key: nextChainKey,\n    index: state.receivingChainKey!.index + 1,\n  };\n\n  return messageKey;\n}\n\n/**\n * Constant-time comparison\n * Prevents timing attacks\n */\nfunction constantTimeEqual(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    const aByte = a[i];\n    const bByte = b[i];\n    if (aByte !== undefined && bByte !== undefined) {\n      result |= aByte ^ bByte;\n    }\n  }\n\n  return result === 0;\n}\n\n/**\n * Clean up ratchet state (zero sensitive data)\n */\nexport function cleanupRatchet(state: RatchetState): void {\n  if (state.rootKey?.key) {\n    secureZeroMemory(state.rootKey.key);\n  }\n  if (state.sendingChainKey?.key) {\n    secureZeroMemory(state.sendingChainKey.key);\n  }\n  if (state.receivingChainKey?.key) {\n    secureZeroMemory(state.receivingChainKey.key);\n  }\n  if (state.sendingEphemeralKey?.privateKey) {\n    secureZeroMemory(state.sendingEphemeralKey.privateKey);\n  }\n\n  // Clean up skipped message keys\n  for (const key of state.skippedMessageKeys.values()) {\n    secureZeroMemory(key.encryptionKey);\n    secureZeroMemory(key.macKey);\n  }\n  state.skippedMessageKeys.clear();\n}\n\n", "/**\r\n * HKDF (HMAC-based Key Derivation Function)\r\n * \r\n * Implements HKDF-SHA-256 as specified in RFC 5869.\r\n * Used for secure key derivation with domain separation.\r\n */\r\n\r\nimport { hmac } from '@noble/hashes/hmac';\r\nimport { sha256 } from '@noble/hashes/sha256';\r\nimport { CRYPTO_CONSTANTS } from './constants.js';\r\n\r\n/**\r\n * Extract phase of HKDF\r\n * \r\n * @param salt - Optional salt (use zero if not provided)\r\n * @param inputKeyMaterial - Input key material (IKM)\r\n * @returns Pseudo-random key (PRK)\r\n */\r\nfunction hkdfExtract(salt: Uint8Array | null, inputKeyMaterial: Uint8Array): Uint8Array {\r\n  const actualSalt = salt || new Uint8Array(CRYPTO_CONSTANTS.CHAIN_KEY_SIZE);\r\n  return hmac(sha256, actualSalt, inputKeyMaterial);\r\n}\r\n\r\n/**\r\n * Expand phase of HKDF\r\n * \r\n * @param prk - Pseudo-random key from extract phase\r\n * @param info - Context and application specific information\r\n * @param length - Desired output length in bytes\r\n * @returns Output keying material (OKM)\r\n */\r\nfunction hkdfExpand(prk: Uint8Array, info: Uint8Array, length: number): Uint8Array {\r\n  if (length > 255 * 32) {\r\n    throw new Error('HKDF output length too large');\r\n  }\r\n\r\n  const n = Math.ceil(length / 32);\r\n  const output = new Uint8Array(length);\r\n  let prev = new Uint8Array(0); // T(0) is empty\r\n\r\n  let offset = 0;\r\n  for (let i = 1; i <= n; i++) {\r\n    // T(i) = HMAC-Hash(PRK, T(i-1) | INFO | i)\r\n    const data = new Uint8Array(prev.length + info.length + 1);\r\n    data.set(prev, 0);\r\n    data.set(info, prev.length);\r\n    data[data.length - 1] = i;\r\n\r\n    const hmacResult = hmac(sha256, prk, data);\r\n    prev = hmacResult; // T(i) becomes T(i-1) for next iter\r\n\r\n    const copyLength = Math.min(32, length - offset);\r\n    output.set(hmacResult.slice(0, copyLength), offset);\r\n    offset += copyLength;\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\n/**\r\n * HKDF: Extract-then-Expand key derivation\r\n * \r\n * @param inputKeyMaterial - Input key material (e.g., shared secret)\r\n * @param salt - Optional salt (defaults to zeros)\r\n * @param info - Context information for domain separation\r\n * @param length - Desired output length\r\n * @returns Derived key material\r\n */\r\nexport function hkdf(\r\n  inputKeyMaterial: Uint8Array,\r\n  salt: Uint8Array | null,\r\n  info: Uint8Array | string,\r\n  length: number\r\n): Uint8Array {\r\n  if (length === 0) {\r\n    throw new Error('HKDF output length must be > 0');\r\n  }\r\n\r\n  const infoBytes = typeof info === 'string'\r\n    ? new TextEncoder().encode(info)\r\n    : info;\r\n\r\n  const prk = hkdfExtract(salt, inputKeyMaterial);\r\n  return hkdfExpand(prk, infoBytes, length);\r\n}\r\n\r\n/**\r\n * Derive root key from shared secret\r\n */\r\nexport function deriveRootKey(sharedSecret: Uint8Array): Uint8Array {\r\n  return hkdf(\r\n    sharedSecret,\r\n    null,\r\n    CRYPTO_CONSTANTS.HKDF_ROOT_KEY_INFO,\r\n    CRYPTO_CONSTANTS.ROOT_KEY_SIZE\r\n  );\r\n}\r\n\r\n/**\r\n * Derive chain key from root key\r\n */\r\nexport function deriveChainKey(rootKey: Uint8Array, info?: string): Uint8Array {\r\n  const infoString = info || CRYPTO_CONSTANTS.HKDF_CHAIN_KEY_INFO;\r\n  return hkdf(\r\n    rootKey,\r\n    null,\r\n    infoString,\r\n    CRYPTO_CONSTANTS.CHAIN_KEY_SIZE\r\n  );\r\n}\r\n\r\n/**\r\n * Derive message key from chain key\r\n * \r\n * Returns both the message key (encryption key) and the next chain key.\r\n * Note: MAC key should be derived separately from the message key.\r\n */\r\nexport function deriveMessageKey(chainKey: Uint8Array): {\r\n  messageKey: Uint8Array;  // 32 bytes - encryption key\r\n  nextChainKey: Uint8Array; // 32 bytes - next chain key\r\n} {\r\n  // Derive 64 bytes: 32 for message key (encryption key), 32 for next chain key\r\n  const output = hkdf(\r\n    chainKey,\r\n    null,\r\n    CRYPTO_CONSTANTS.HKDF_MESSAGE_KEY_INFO,\r\n    64\r\n  );\r\n\r\n  return {\r\n    messageKey: output.slice(0, 32),      // Encryption key\r\n    nextChainKey: output.slice(32, 64),   // Next chain key\r\n  };\r\n}\r\n\r\n", "import { hash as assertHash, bytes as assertBytes, exists as assertExists } from './_assert.js';\nimport { Hash, CHash, Input, toBytes } from './utils.js';\n// HMAC (RFC 2104)\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    assertHash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf: Input) {\n    assertExists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assertExists(this);\n    assertBytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nexport const hmac = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n", "import { SHA2 } from './_sha2.js';\nimport { rotr, wrapConstructor } from './utils.js';\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n\n// Choice: a ? b : c\nconst Chi = (a: number, b: number, c: number) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a: number, b: number, c: number) => (a & b) ^ (a & c) ^ (b & c);\n\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = /* @__PURE__ */new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends SHA2<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  A = IV[0] | 0;\n  B = IV[1] | 0;\n  C = IV[2] | 0;\n  D = IV[3] | 0;\n  E = IV[4] | 0;\n  F = IV[5] | 0;\n  G = IV[6] | 0;\n  H = IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n  A = 0xc1059ed8 | 0;\n  B = 0x367cd507 | 0;\n  C = 0x3070dd17 | 0;\n  D = 0xf70e5939 | 0;\n  E = 0xffc00b31 | 0;\n  F = 0x68581511 | 0;\n  G = 0x64f98fa7 | 0;\n  H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nexport const sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\nexport const sha224 = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n", "/**\r\n * Handshake Protocol\r\n * \r\n * Implements a secure handshake based on Noise Protocol Framework.\r\n * Provides mutual authentication and key establishment.\r\n * \r\n * Handshake flow:\r\n * 1. Client sends HandshakeInit (ephemeral key + identity signature)\r\n * 2. Server responds with HandshakeResponse (ephemeral key + encrypted prekey)\r\n * 3. Client sends HandshakeComplete (confirmation)\r\n */\r\n\r\nimport type {\r\n  IdentityKeyPair,\r\n  EphemeralKeyPair,\r\n  PublicKey,\r\n} from '../crypto/types.js';\r\nimport {\r\n  generateNonce,\r\n  sign,\r\n  verify,\r\n  computeSharedSecret,\r\n} from '../crypto/keygen.js';\r\nimport {\r\n  deriveRootKey,\r\n} from '../crypto/hkdf.js';\r\nimport { encrypt, decrypt, computeMAC } from '../crypto/encryption.js';\r\nimport { CRYPTO_CONSTANTS } from '../crypto/constants.js';\r\n\r\nexport interface HandshakeState {\r\n  identityKey: IdentityKeyPair;\r\n  ephemeralKey?: EphemeralKeyPair;\r\n  remoteIdentityPublicKey?: PublicKey;\r\n  remoteEphemeralPublicKey?: PublicKey;\r\n  rootKey?: Uint8Array;\r\n  handshakeComplete: boolean;\r\n}\r\n\r\n/**\r\n * Create initial handshake message\r\n */\r\nexport function createHandshakeInit(\r\n  identityKey: IdentityKeyPair,\r\n  ephemeralKey: EphemeralKeyPair\r\n): {\r\n  message: Uint8Array;\r\n  state: HandshakeState;\r\n} {\r\n  const timestamp = BigInt(Date.now());\r\n  const nonce = generateNonce();\r\n  \r\n  // Create signature: sign(ephemeral_public_key || identity_public_key || timestamp || nonce)\r\n  const signatureData = new Uint8Array(\r\n    ephemeralKey.publicKey.length +\r\n    identityKey.publicKey.length +\r\n    8 + // timestamp\r\n    nonce.length\r\n  );\r\n  let offset = 0;\r\n  signatureData.set(ephemeralKey.publicKey, offset);\r\n  offset += ephemeralKey.publicKey.length;\r\n  signatureData.set(identityKey.publicKey, offset);\r\n  offset += identityKey.publicKey.length;\r\n  \r\n  // Encode timestamp as big-endian\r\n  const timestampBytes = new Uint8Array(8);\r\n  const timestampView = new BigUint64Array(timestampBytes.buffer);\r\n  timestampView[0] = timestamp;\r\n  signatureData.set(timestampBytes, offset);\r\n  offset += 8;\r\n  signatureData.set(nonce, offset);\r\n  \r\n  const signature = sign(identityKey.privateKey, signatureData);\r\n  \r\n  // Create handshake init message\r\n  // Format: ephemeral_key(32) || identity_key(32) || signature(64) || timestamp(8) || nonce(16)\r\n  const message = new Uint8Array(\r\n    ephemeralKey.publicKey.length +\r\n    identityKey.publicKey.length +\r\n    signature.length +\r\n    8 +\r\n    nonce.length\r\n  );\r\n  offset = 0;\r\n  message.set(ephemeralKey.publicKey, offset);\r\n  offset += ephemeralKey.publicKey.length;\r\n  message.set(identityKey.publicKey, offset);\r\n  offset += identityKey.publicKey.length;\r\n  message.set(signature, offset);\r\n  offset += signature.length;\r\n  message.set(timestampBytes, offset);\r\n  offset += 8;\r\n  message.set(nonce, offset);\r\n  \r\n  const state: HandshakeState = {\r\n    identityKey,\r\n    ephemeralKey,\r\n    handshakeComplete: false,\r\n  };\r\n  \r\n  return { message, state };\r\n}\r\n\r\n/**\r\n * Process handshake init and create response\r\n */\r\nexport async function processHandshakeInit(\r\n  message: Uint8Array,\r\n  serverIdentityKey: IdentityKeyPair,\r\n  serverEphemeralKey: EphemeralKeyPair\r\n): Promise<{\r\n  response: Uint8Array;\r\n  state: HandshakeState;\r\n  clientIdentityPublicKey: PublicKey;\r\n}> {\r\n  // Parse message\r\n  if (message.length < 32 + 32 + 64 + 8 + 16) {\r\n    throw new Error('Invalid handshake init message');\r\n  }\r\n  \r\n  let offset = 0;\r\n  const clientEphemeralPublicKey = message.slice(offset, offset + 32);\r\n  offset += 32;\r\n  const clientIdentityPublicKey = message.slice(offset, offset + 32);\r\n  offset += 32;\r\n  const signature = message.slice(offset, offset + 64);\r\n  offset += 64;\r\n  const timestampBytes = message.slice(offset, offset + 8);\r\n  offset += 8;\r\n  const nonce = message.slice(offset, offset + 16);\r\n  offset += 16;\r\n  \r\n  // Verify signature\r\n  const signatureData = new Uint8Array(\r\n    clientEphemeralPublicKey.length +\r\n    clientIdentityPublicKey.length +\r\n    timestampBytes.length +\r\n    nonce.length\r\n  );\r\n  let sigOffset = 0;\r\n  signatureData.set(clientEphemeralPublicKey, sigOffset);\r\n  sigOffset += clientEphemeralPublicKey.length;\r\n  signatureData.set(clientIdentityPublicKey, sigOffset);\r\n  sigOffset += clientIdentityPublicKey.length;\r\n  signatureData.set(timestampBytes, sigOffset);\r\n  sigOffset += timestampBytes.length;\r\n  signatureData.set(nonce, sigOffset);\r\n  \r\n  if (!verify(clientIdentityPublicKey, signatureData, signature)) {\r\n    throw new Error('Handshake signature verification failed');\r\n  }\r\n  \r\n  // Check timestamp (prevent replay attacks)\r\n  const timestamp = Number(new BigUint64Array(timestampBytes.buffer)[0]);\r\n  const now = Date.now();\r\n  const skew = Math.abs(now - timestamp);\r\n  if (skew > CRYPTO_CONSTANTS.MAX_CLOCK_SKEW_MS) {\r\n    throw new Error('Handshake timestamp out of acceptable range');\r\n  }\r\n  \r\n  // Compute shared secret\r\n  // Note: We use only ephemeral keys for key exchange. Identity keys are for authentication (signing) only.\r\n  const ss1 = computeSharedSecret(\r\n    serverEphemeralKey.privateKey,\r\n    clientEphemeralPublicKey\r\n  );\r\n  \r\n  // Derive root key from single shared secret\r\n  const rootKey = deriveRootKey(ss1);\r\n  \r\n  // Create encrypted prekey material\r\n  const prekeyMaterial = new Uint8Array(32); // Placeholder\r\n  crypto.getRandomValues(prekeyMaterial);\r\n  \r\n  const timestampResponse = BigInt(Date.now());\r\n  const nonceResponse = generateNonce();\r\n  \r\n  // Encrypt prekey material\r\n  const { ciphertext, tag, iv } = await encrypt(\r\n    prekeyMaterial,\r\n    rootKey,\r\n    undefined,\r\n    new TextEncoder().encode('handshake-prekey')\r\n  );\r\n  \r\n  // Create response message\r\n  // Format: server_ephemeral_key(32) || encrypted_prekey(32) || tag(16) || iv(12) || timestamp(8) || nonce(16)\r\n  const response = new Uint8Array(\r\n    serverEphemeralKey.publicKey.length +\r\n    ciphertext.length +\r\n    tag.length +\r\n    iv.length +\r\n    8 +\r\n    nonceResponse.length\r\n  );\r\n  offset = 0;\r\n  response.set(serverEphemeralKey.publicKey, offset);\r\n  offset += serverEphemeralKey.publicKey.length;\r\n  response.set(ciphertext, offset);\r\n  offset += ciphertext.length;\r\n  response.set(tag, offset);\r\n  offset += tag.length;\r\n  response.set(iv, offset);\r\n  offset += iv.length;\r\n  \r\n  const timestampResponseBytes = new Uint8Array(8);\r\n  const timestampResponseView = new BigUint64Array(timestampResponseBytes.buffer);\r\n  timestampResponseView[0] = timestampResponse;\r\n  response.set(timestampResponseBytes, offset);\r\n  offset += 8;\r\n  response.set(nonceResponse, offset);\r\n  \r\n  const state: HandshakeState = {\r\n    identityKey: serverIdentityKey,\r\n    ephemeralKey: serverEphemeralKey,\r\n    remoteIdentityPublicKey: clientIdentityPublicKey,\r\n    remoteEphemeralPublicKey: clientEphemeralPublicKey,\r\n    rootKey,\r\n    handshakeComplete: false,\r\n  };\r\n  \r\n  return {\r\n    response,\r\n    state,\r\n    clientIdentityPublicKey,\r\n  };\r\n}\r\n\r\n/**\r\n * Process handshake response and complete handshake\r\n */\r\nexport async function processHandshakeResponse(\r\n  message: Uint8Array,\r\n  state: HandshakeState\r\n): Promise<{\r\n  confirmation: Uint8Array;\r\n  rootKey: Uint8Array;\r\n}> {\r\n  if (!state.ephemeralKey) {\r\n    throw new Error('Handshake state missing ephemeral key');\r\n  }\r\n  \r\n  // Parse response\r\n  if (message.length < 32 + 32 + 16 + 12 + 8 + 16) {\r\n    throw new Error('Invalid handshake response message');\r\n  }\r\n  \r\n  let offset = 0;\r\n  const serverEphemeralPublicKey = message.slice(offset, offset + 32);\r\n  offset += 32;\r\n  const encryptedPrekey = message.slice(offset, offset + 32);\r\n  offset += 32;\r\n  const tag = message.slice(offset, offset + 16);\r\n  offset += 16;\r\n  const iv = message.slice(offset, offset + 12);\r\n  offset += 12;\r\n  const timestampBytes = message.slice(offset, offset + 8);\r\n  offset += 8;\r\n  // Parse nonce (reserved for future nonce tracking/uniqueness validation)\r\n  message.slice(offset, offset + 16);\r\n  offset += 16;\r\n  \r\n  // Validate timestamp (prevent replay attacks)\r\n  const timestamp = Number(new BigUint64Array(timestampBytes.buffer, 0, 1)[0]);\r\n  const now = Date.now();\r\n  const skew = Math.abs(now - timestamp);\r\n  if (skew > CRYPTO_CONSTANTS.MAX_CLOCK_SKEW_MS) {\r\n    throw new Error('Handshake timestamp out of acceptable range');\r\n  }\r\n  \r\n  // Note: nonce validation (uniqueness check) would require state tracking\r\n  // For now, timestamp validation provides replay protection\r\n  \r\n  // Compute shared secret\r\n  // Note: We use only ephemeral keys for key exchange. Identity keys are for authentication (signing) only.\r\n  const ss1 = computeSharedSecret(\r\n    state.ephemeralKey.privateKey,\r\n    serverEphemeralPublicKey\r\n  );\r\n  \r\n  // Derive root key from single shared secret\r\n  const rootKey = deriveRootKey(ss1);\r\n  \r\n  // Decrypt prekey material\r\n  const prekeyMaterial = await decrypt(\r\n    encryptedPrekey,\r\n    tag,\r\n    rootKey,\r\n    iv,\r\n    new TextEncoder().encode('handshake-prekey')\r\n  );\r\n  \r\n  // Create confirmation\r\n  const confirmationData = new Uint8Array(\r\n    state.ephemeralKey.publicKey.length +\r\n    serverEphemeralPublicKey.length +\r\n    prekeyMaterial.length\r\n  );\r\n  offset = 0;\r\n  confirmationData.set(state.ephemeralKey.publicKey, offset);\r\n  offset += state.ephemeralKey.publicKey.length;\r\n  confirmationData.set(serverEphemeralPublicKey, offset);\r\n  offset += serverEphemeralPublicKey.length;\r\n  confirmationData.set(prekeyMaterial, offset);\r\n  \r\n  const confirmation = await computeMAC(confirmationData, rootKey);\r\n  \r\n  state.rootKey = rootKey;\r\n  state.remoteEphemeralPublicKey = serverEphemeralPublicKey;\r\n  state.handshakeComplete = true;\r\n  \r\n  return {\r\n    confirmation,\r\n    rootKey,\r\n  };\r\n}\r\n\r\n", "/**\r\n * Encryption and decryption operations\r\n * \r\n * Uses AES-256-GCM for authenticated encryption.\r\n * All operations are designed to be constant-time where possible.\r\n */\r\n\r\nimport { randomBytes } from '@noble/hashes/utils';\r\nimport type { Ciphertext, MAC, Nonce } from './types.js';\r\nimport { CRYPTO_CONSTANTS } from './constants.js';\r\n\r\n/**\r\n * Encrypt plaintext with AES-256-GCM\r\n * \r\n * @param plaintext - Data to encrypt\r\n * @param key - 32-byte encryption key\r\n * @param iv - 12-byte initialization vector (generated if not provided)\r\n * @param additionalData - Optional authenticated additional data\r\n * @returns Object containing ciphertext and authentication tag\r\n */\r\nexport async function encrypt(\r\n  plaintext: Uint8Array,\r\n  key: Uint8Array,\r\n  iv?: Uint8Array,\r\n  additionalData?: Uint8Array\r\n): Promise<{ ciphertext: Ciphertext; tag: MAC; iv: Nonce }> {\r\n  if (key.length !== CRYPTO_CONSTANTS.MESSAGE_KEY_SIZE) {\r\n    throw new Error('Invalid encryption key size');\r\n  }\r\n  \r\n  if (plaintext.length > CRYPTO_CONSTANTS.MAX_MESSAGE_SIZE) {\r\n    throw new Error('Message too large');\r\n  }\r\n  \r\n  const actualIv = iv || randomBytes(CRYPTO_CONSTANTS.AES_IV_SIZE);\r\n  \r\n  if (actualIv.length !== CRYPTO_CONSTANTS.AES_IV_SIZE) {\r\n    throw new Error('Invalid IV size');\r\n  }\r\n  \r\n  // Use Web Crypto API for AES-GCM\r\n  const cryptoKey = await crypto.subtle.importKey(\r\n    'raw',\r\n    key,\r\n    { name: 'AES-GCM' },\r\n    false,\r\n    ['encrypt']\r\n  );\r\n  \r\n  const encrypted = await crypto.subtle.encrypt(\r\n    {\r\n      name: 'AES-GCM',\r\n      iv: actualIv,\r\n      tagLength: CRYPTO_CONSTANTS.AES_TAG_SIZE * 8, // in bits\r\n      additionalData,\r\n    },\r\n    cryptoKey,\r\n    plaintext\r\n  );\r\n  \r\n  // GCM tag is appended to ciphertext\r\n  const totalLength = encrypted.byteLength;\r\n  const tagLength = CRYPTO_CONSTANTS.AES_TAG_SIZE;\r\n  const ciphertextLength = totalLength - tagLength;\r\n  \r\n  return {\r\n    ciphertext: new Uint8Array(encrypted.slice(0, ciphertextLength)),\r\n    tag: new Uint8Array(encrypted.slice(ciphertextLength)),\r\n    iv: actualIv,\r\n  };\r\n}\r\n\r\n/**\r\n * Decrypt ciphertext with AES-256-GCM\r\n * \r\n * @param ciphertext - Encrypted data\r\n * @param tag - Authentication tag\r\n * @param key - 32-byte decryption key\r\n * @param iv - 12-byte initialization vector\r\n * @param additionalData - Optional authenticated additional data\r\n * @returns Decrypted plaintext\r\n * @throws Error if decryption or authentication fails\r\n */\r\nexport async function decrypt(\r\n  ciphertext: Ciphertext,\r\n  tag: MAC,\r\n  key: Uint8Array,\r\n  iv: Nonce,\r\n  additionalData?: Uint8Array\r\n): Promise<Uint8Array> {\r\n  if (key.length !== CRYPTO_CONSTANTS.MESSAGE_KEY_SIZE) {\r\n    throw new Error('Invalid decryption key size');\r\n  }\r\n  \r\n  if (iv.length !== CRYPTO_CONSTANTS.AES_IV_SIZE) {\r\n    throw new Error('Invalid IV size');\r\n  }\r\n  \r\n  if (tag.length !== CRYPTO_CONSTANTS.AES_TAG_SIZE) {\r\n    throw new Error('Invalid tag size');\r\n  }\r\n  \r\n  // Combine ciphertext and tag for Web Crypto API\r\n  const encrypted = new Uint8Array(ciphertext.length + tag.length);\r\n  encrypted.set(ciphertext, 0);\r\n  encrypted.set(tag, ciphertext.length);\r\n  \r\n  const cryptoKey = await crypto.subtle.importKey(\r\n    'raw',\r\n    key,\r\n    { name: 'AES-GCM' },\r\n    false,\r\n    ['decrypt']\r\n  );\r\n  \r\n  try {\r\n    const decrypted = await crypto.subtle.decrypt(\r\n      {\r\n        name: 'AES-GCM',\r\n        iv,\r\n        tagLength: CRYPTO_CONSTANTS.AES_TAG_SIZE * 8,\r\n        additionalData,\r\n      },\r\n      cryptoKey,\r\n      encrypted\r\n    );\r\n    \r\n    return new Uint8Array(decrypted);\r\n  } catch (error) {\r\n    // Authentication failure - don't leak information about why\r\n    throw new Error('Decryption failed: authentication error');\r\n  }\r\n}\r\n\r\n/**\r\n * Compute HMAC-SHA-256\r\n */\r\nexport async function computeMAC(\r\n  data: Uint8Array,\r\n  key: Uint8Array\r\n): Promise<MAC> {\r\n  if (key.length !== CRYPTO_CONSTANTS.MAC_KEY_SIZE) {\r\n    throw new Error('Invalid MAC key size');\r\n  }\r\n  \r\n  const cryptoKey = await crypto.subtle.importKey(\r\n    'raw',\r\n    key,\r\n    { name: 'HMAC', hash: 'SHA-256' },\r\n    false,\r\n    ['sign']\r\n  );\r\n  \r\n  const signature = await crypto.subtle.sign('HMAC', cryptoKey, data);\r\n  return new Uint8Array(signature);\r\n}\r\n\r\n/**\r\n * Verify HMAC-SHA-256\r\n */\r\nexport async function verifyMAC(\r\n  data: Uint8Array,\r\n  key: Uint8Array,\r\n  mac: MAC\r\n): Promise<boolean> {\r\n  const computedMac = await computeMAC(data, key);\r\n  \r\n  // Constant-time comparison\r\n  if (computedMac.length !== mac.length) {\r\n    return false;\r\n  }\r\n  \r\n  let result = 0;\r\n  for (let i = 0; i < mac.length; i++) {\r\n    const computedByte = computedMac[i];\r\n    const macByte = mac[i];\r\n    if (computedByte !== undefined && macByte !== undefined) {\r\n      result |= computedByte ^ macByte;\r\n    }\r\n  }\r\n  \r\n  return result === 0;\r\n}\r\n\r\n", "/**\n * PRODUCTION-READY Message Protocol\n * \n * Features:\n * - Sequence numbers for ordering\n * - Proper header encryption\n * - Replay detection\n * - Message deduplication\n */\n\nimport type {\n  RatchetState,\n  PublicKey,\n} from '../crypto/types.js';\nimport {\n  ratchetEncrypt,\n  ratchetDecrypt,\n} from '../crypto/ratchet.js';\nimport {\n  encrypt,\n  decrypt,\n  computeMAC,\n  verifyMAC,\n} from '../crypto/encryption.js';\nimport {\n  generateMessageId,\n} from '../crypto/keygen.js';\nimport { CRYPTO_CONSTANTS } from '../crypto/constants.js';\n\nexport interface EncryptedMessageData {\n  messageId: Uint8Array;\n  sequence: number;           // NEW: For ordering\n  header: Uint8Array;\n  ciphertext: Uint8Array;\n  mac: Uint8Array;\n  timestamp: number;\n  version: number;\n}\n\nexport interface MessageHeader {\n  sequence: number;           // NEW: Sequence number\n  dhPublicKey: PublicKey;\n  messageNumber: number;\n  previousChainLength: number;\n}\n\nexport async function encryptMessage(\n  plaintext: Uint8Array,\n  ratchetState: RatchetState,\n  _recipientPublicKey?: PublicKey\n): Promise<EncryptedMessageData> {\n  if (plaintext.length > CRYPTO_CONSTANTS.MAX_MESSAGE_SIZE) {\n    throw new Error('Message too large');\n  }\n\n  const ratchetResult = ratchetEncrypt(ratchetState, plaintext);\n  const messageKey = ratchetResult.messageKey;\n\n  const iv = new Uint8Array(CRYPTO_CONSTANTS.AES_IV_SIZE);\n  crypto.getRandomValues(iv);\n  messageKey.iv = iv;\n\n  const { ciphertext, tag } = await encrypt(\n    plaintext,\n    messageKey.encryptionKey,\n    iv\n  );\n\n  const sequence = ratchetState.sendCounter++;\n\n  const header: MessageHeader = {\n    sequence,                                              // NEW\n    dhPublicKey: ratchetState.sendingEphemeralKey!.publicKey,\n    messageNumber: messageKey.index,\n    previousChainLength: ratchetState.previousChainLength,\n  };\n\n  const headerBytes = serializeHeader(header);\n\n  const { ciphertext: encryptedHeader, tag: headerTag } = await encrypt(\n    headerBytes,\n    messageKey.encryptionKey,\n    undefined,\n    ciphertext\n  );\n\n  const fullHeader = new Uint8Array(encryptedHeader.length + headerTag.length);\n  fullHeader.set(encryptedHeader, 0);\n  fullHeader.set(headerTag, encryptedHeader.length);\n\n  const macData = new Uint8Array(\n    fullHeader.length +\n    ciphertext.length +\n    tag.length +\n    4  // sequence number\n  );\n  let offset = 0;\n\n  const sequenceView = new DataView(macData.buffer, macData.byteOffset, 4);\n  sequenceView.setUint32(0, sequence, false);\n  offset += 4;\n\n  macData.set(fullHeader, offset);\n  offset += fullHeader.length;\n  macData.set(ciphertext, offset);\n  offset += ciphertext.length;\n  macData.set(tag, offset);\n\n  const mac = await computeMAC(macData, messageKey.macKey);\n\n  const messageId = generateMessageId();\n\n  return {\n    messageId,\n    sequence,                                              // NEW\n    header: fullHeader,\n    ciphertext,\n    mac,\n    timestamp: Date.now(),\n    version: CRYPTO_CONSTANTS.PROTOCOL_VERSION,\n  };\n}\n\nexport async function decryptMessage(\n  encryptedData: EncryptedMessageData,\n  ratchetState: RatchetState\n): Promise<Uint8Array> {\n  if (encryptedData.sequence !== ratchetState.receiveCounter) {\n    throw new Error(`Sequence mismatch: expected ${ratchetState.receiveCounter}, got ${encryptedData.sequence}`);\n  }\n\n  const headerCiphertext = encryptedData.header.slice(0, -16);\n  const headerTag = encryptedData.header.slice(-16);\n\n  const tempMessageKey = ratchetState.receivingChainKey;\n  if (!tempMessageKey) {\n    throw new Error('No receiving chain key available for header decryption');\n  }\n\n  const tempIv = new Uint8Array(CRYPTO_CONSTANTS.AES_IV_SIZE);\n  crypto.getRandomValues(tempIv);\n\n  const headerBytes = await decrypt(\n    headerCiphertext,\n    headerTag,\n    tempMessageKey.key.slice(0, 32),\n    tempIv,\n    encryptedData.ciphertext\n  );\n\n  const header = deserializeHeader(headerBytes);\n\n  if (header.sequence !== encryptedData.sequence) {\n    throw new Error('Header sequence mismatch');\n  }\n\n  const messageKey = ratchetDecrypt(\n    ratchetState,\n    header.dhPublicKey,\n    header.messageNumber,\n    header.previousChainLength\n  );\n\n  messageKey.iv = tempIv;\n\n  const macData = new Uint8Array(\n    4 +\n    encryptedData.header.length +\n    encryptedData.ciphertext.length +\n    16\n  );\n  let offset = 0;\n\n  const sequenceView = new DataView(macData.buffer, macData.byteOffset, 4);\n  sequenceView.setUint32(0, encryptedData.sequence, false);\n  offset += 4;\n\n  macData.set(encryptedData.header, offset);\n  offset += encryptedData.header.length;\n  macData.set(encryptedData.ciphertext, offset);\n  offset += encryptedData.ciphertext.length;\n  const tag = encryptedData.ciphertext.slice(-16);\n  macData.set(tag, offset);\n\n  const macValid = await verifyMAC(macData, messageKey.macKey, encryptedData.mac);\n  if (!macValid) {\n    throw new Error('MAC verification failed');\n  }\n\n  ratchetState.receiveCounter++;\n\n  const plaintext = await decrypt(\n    encryptedData.ciphertext,\n    tag,\n    messageKey.encryptionKey,\n    messageKey.iv!\n  );\n\n  return plaintext;\n}\n\nfunction serializeHeader(header: MessageHeader): Uint8Array {\n  const buffer = new Uint8Array(\n    4 +  // sequence\n    32 + // dhPublicKey\n    4 +  // messageNumber\n    4    // previousChainLength\n  );\n  let offset = 0;\n\n  let view = new DataView(buffer.buffer, offset, 4);\n  view.setUint32(0, header.sequence, false);\n  offset += 4;\n\n  buffer.set(header.dhPublicKey, offset);\n  offset += 32;\n\n  view = new DataView(buffer.buffer, offset, 4);\n  view.setUint32(0, header.messageNumber, false);\n  offset += 4;\n\n  view = new DataView(buffer.buffer, offset, 4);\n  view.setUint32(0, header.previousChainLength, false);\n\n  return buffer;\n}\n\nexport function deserializeHeader(data: Uint8Array): MessageHeader {\n  if (data.length < 44) {\n    throw new Error('Invalid header data');\n  }\n\n  let offset = 0;\n  const sequence = new DataView(data.buffer, data.byteOffset + offset, 4).getUint32(0, false);\n  offset += 4;\n\n  const dhPublicKey = data.slice(offset, offset + 32);\n  offset += 32;\n\n  const messageNumber = new DataView(data.buffer, data.byteOffset + offset, 4).getUint32(0, false);\n  offset += 4;\n\n  const previousChainLength = new DataView(data.buffer, data.byteOffset + offset, 4).getUint32(0, false);\n\n  return {\n    sequence,\n    dhPublicKey,\n    messageNumber,\n    previousChainLength,\n  };\n}\n", "/**\n * Browser WebSocket adapter\n * Adapts the native WebSocket API to work with our client\n */\n\nexport class BrowserWebSocket extends EventTarget {\n  private ws: WebSocket;\n  private listeners: Map<Function, EventListener> = new Map();\n\n  constructor(url: string) {\n    super();\n    this.ws = new WebSocket(url);\n    this.ws.binaryType = 'arraybuffer';\n\n    this.ws.onopen = () => {\n      this.dispatchEvent(new Event('open'));\n    };\n\n    this.ws.onclose = (event) => {\n      const closeEvent = new CustomEvent('close', {\n        detail: {\n          code: event.code,\n          reason: event.reason,\n          wasClean: event.wasClean\n        }\n      });\n      this.dispatchEvent(closeEvent);\n    };\n\n    this.ws.onerror = () => {\n      this.dispatchEvent(new Event('error'));\n    };\n\n    this.ws.onmessage = async (event) => {\n      let data: ArrayBuffer;\n\n      if (event.data instanceof Blob) {\n        data = await event.data.arrayBuffer();\n      } else if (event.data instanceof ArrayBuffer) {\n        data = event.data;\n      } else {\n        console.error('Unexpected message type:', typeof event.data);\n        return;\n      }\n\n      const messageEvent = new MessageEvent('message', {\n        data: Buffer.from(data),\n      });\n      this.dispatchEvent(messageEvent);\n    };\n  }\n\n  get readyState(): number {\n    return this.ws.readyState;\n  }\n\n  get OPEN(): number {\n    return WebSocket.OPEN;\n  }\n\n  /**\n   * Send data to server\n   * @param data - Data to send\n   */\n  send(data: Uint8Array | ArrayBuffer): void {\n    this.ws.send(data);\n  }\n\n  /**\n   * Close the connection\n   * @param code - Close code\n   * @param reason - Close reason\n   */\n  close(code?: number, reason?: string): void {\n    this.ws.close(code, reason);\n  }\n\n  /**\n   * Add event listener(Node.js style)\n   * @param event - Event name\n   * @param handler - Event handler\n   */\n  on(event: string, handler: (...args: any[]) => void): void {\n    const wrapper = (e: Event) => {\n      if (event === 'message' && e instanceof MessageEvent) {\n        handler(e.data);\n      } else if (event === 'close' && e instanceof CustomEvent) {\n        handler(e.detail.code, e.detail.reason);\n      } else {\n        handler();\n      }\n    };\n\n    // Store wrapper for removal\n    this.listeners.set(handler, wrapper as EventListener);\n    this.addEventListener(event, wrapper as EventListener);\n  }\n\n  /**\n   * Remove event listener(Node.js style)\n   * @param event - Event name\n   * @param handler - Event handler to remove\n   */\n  removeListener(event: string, handler: (...args: any[]) => void): void {\n    const wrapper = this.listeners.get(handler);\n    if (wrapper) {\n      this.removeEventListener(event, wrapper);\n      this.listeners.delete(handler);\n    }\n  }\n}\n\n// Polyfill Buffer for browser if needed\nif (typeof globalThis.Buffer === 'undefined') {\n  (globalThis as any).Buffer = {\n    from(data: ArrayBuffer | Uint8Array | number[]): Uint8Array {\n      if (data instanceof ArrayBuffer) {\n        return new Uint8Array(data);\n      }\n      if (data instanceof Uint8Array) {\n        return data;\n      }\n      return new Uint8Array(data);\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": ["bytes", "hash", "crypto", "isBytes", "isBytes", "crypto", "isLE", "_32n", "bytes", "bytes", "concatBytes", "_0n", "_1n", "_2n", "number", "Fp", "isLE", "_0n", "_1n", "bytes", "Fp", "_0n", "_1n", "window", "_0n", "_1n", "_2n", "_8n", "Fp", "randomBytes", "uvRatio", "adjustScalarBytes", "bytes", "G", "A", "B", "F", "C", "D", "E", "H", "X3", "Y3", "T3", "Z3", "cofactor", "hash", "concatBytes", "sign", "verify", "_0n", "_1n", "validateOpts", "adjustScalarBytes", "bytes", "_0n", "_1n", "_2n", "_5n", "bytes", "pow", "_2n", "hash", "output"]
}
